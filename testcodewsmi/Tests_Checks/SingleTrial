import numpy as np
import mne
import pickle
import matplotlib.pyplot as plt
from nice.algorithms.connectivity import epochs_compute_wsmi
np.set_printoptions(threshold=100)  #default threshold
from scipy.ndimage import gaussian_filter1d
from scipy.stats import zscore
from scipy.signal import detrend

#load data
file_path = 'C:/Users/joshu/PartIIIProject/RSNNdale_attention_1_attention_test'
data = pickle.load(open(file_path, 'rb'))

attention_labels = data['label_attend'][0]
label_left = data['label_left'][0]
label_right = data['label_right'][0]
attend_01 = data['attend'][0]


#not filtered for omitted trials 
left_input_LFP = data['LFP'][0][0]  # Left input  [0,1] means left, Right 
right_input_LFP = data['LFP'][0][1]  # Right input
attention_LFP = data['LFP_rec'][0][2]  # Attention layer  [2] means attention 
omitted = data["omit"][0]


trial_idx = 1
left_input_trial = left_input_LFP[trial_idx][100:350]
right_input_trial= right_input_LFP[trial_idx][100:350]
attention_trial = attention_LFP[trial_idx][100:350]

#using zscore function
left_input_trial_zscore = zscore(left_input_trial)
right_input_trial_zscore = zscore(right_input_trial)
attention_trial_zscore = zscore(attention_trial)


#using detrend function
left_input_trial = detrend(left_input_trial_zscore)
right_input_trial = detrend(right_input_trial_zscore)
attention_trial = detrend(attention_trial_zscore)

plt.plot(left_input_trial_zscore, label='left_input_trial')
plt.plot(right_input_trial_zscore, label='right_input_trial')
plt.plot(attention_trial_zscore, label='attention_trial')
plt.legend()
plt.show()

plt.plot(left_input_trial, label='left_input_trial_detrend')
plt.plot(right_input_trial, label='right_input_trial_detrend')
plt.plot(attention_trial, label='attention_trial_detrend')
plt.legend()
plt.show()


raw_data_raw = np.stack([left_input_trial, right_input_trial, attention_trial])
n_times = raw_data_raw.shape[1] ##=500

dt = 0.002
sfreq = 1 / dt
ch_names = ['left_input', 'right_input', 'attention_layer']
ch_types = ['eeg', 'eeg', 'eeg']
info = mne.create_info(ch_names=ch_names, sfreq=sfreq, ch_types=ch_types)


raw_data = mne.io.RawArray(raw_data_raw, info)

events = np.array([
    [0,0,1]
])


epochs_raw = mne.Epochs(raw_data, events, event_id={'Trial': 1}, tmin=0, tmax=(n_times - 1) / sfreq, baseline=None, preload=True)
epochs_raw.plot(scalings='auto')
plt.show()




kernel = 3
taus = [8, 16, 32, 64]  # in ms
#making wsmi results dictionary to store raw, normalised, and smoothed data
wsmi_results = {}



for tau in taus:
    tau_samples = int(tau / (1000 / sfreq))
    
    wsmi, _, _, _ = epochs_compute_wsmi(
        epochs_raw, kernel=kernel, tau=tau_samples, backend='python', method_params={'bypass_csd': True}
    )

    wsmi_results[tau] = wsmi

#shape 3,3,1

wsmi_left = [wsmi_results[tau][0, 2, :] for tau in taus]
wsmi_right = [wsmi_results[tau][1, 2, :] for tau in taus]
plt.scatter(taus, wsmi_left, label='wsmi_left')
plt.scatter(taus, wsmi_right, label='wsmi_right')
plt.legend()
plt.show()

# Verify the association of [0, 1, :] element with wsmi between left and attention
wsmi_shape = wsmi_results[taus[0]].shape
print(f"wsmi shape: {wsmi_shape}")

# Check the labels of the channels
print(f"Channel names: {ch_names}")

# Check the wsmi values for different channel pairs
for tau in taus:
    wsmi = wsmi_results[tau]
    print(f"tau: {tau}")
    for i in range(wsmi_shape[0]):
        for j in range(wsmi_shape[1]):
            print(f"wsmi[{i}, {j}, :] between {ch_names[i]} and {ch_names[j]}: {wsmi[i, j, :]}")